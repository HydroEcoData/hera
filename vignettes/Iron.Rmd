---
title: "Iron"
output: rmarkdown::html_vignette
editor_options: 
  chunk_output_type: console
runtime: shiny
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  echo = F
)
library(hera)
library(tidyverse)
library(testthat)
```

<!-- Create a new regulatory assessment by changing the CAPITLIZE info below: -->

## Assessment Details

```{r setup}

standard <- tibble(
  standard_short = "Iron", # Short name for standard < 26 characters
  quality_element = "Chemistry", # Quality element  < 26 characters
  parameter = "Iron", # My parameter
  standard_long = NA, # Optional - Long name for standard
  aggregation = NA, # Optional - usually "waterbody" or "area"
  status = NA # Optional - "development", "on-hold", "consultation", "deprecated" or "deployed"
)

standard_format <- hera:::hera_format(standard = standard) # check and format assessment data
knitr::kable(standard_format$standard) # print
```

## Example Data

```{r}
data <- tibble(
  question = "Iron", # Replace NA with your question
  response = 12, # Replace NA with demo response. For instance, Demo string, numeric, dna, geographic etc
  units = NA, # Optional units
  min = NA, # Optional Max value
  max = NA, # Optional Min value
  # Optional aggregations levels:
  #  date = NA
  # waterbody = NA,
  # area = NA
)
data
```

## Index Function 

If applicable...

```{r}

indices <- function(data) {
  # Some calculated index e.g. summary of sample responses: 
  # index = sum(data$response, na.rm = TRUE)
  index <- NA

  data <- tibble(
    question = NA,
    response = NA
  )
  return(data)
}
indices(data)
```

## Predictors

```{r}
predictors <- tibble(
  iron_standard = 2
  # ...
)
knitr::kable(predictors) 
```

## Prediction function

```{r}
prediction <- function(predictors) {

  # Generates prediction based on predictors...
  prediction <- predictors$iron_standard
  return(prediction)
}
predictions <- prediction(predictors)
predictions
```

## Assessment table
```{r}

assessment_table <- tibble(
  asesssment = c( "high", "good", "moderate", "poor",  "bad"),
  value = c(0.80,0.60, 0.40, 0.20, 0)
  # ...
  # "red" = 0.33
  # "amber" = 0.5
  # "green" = 0.66
  
  # "pass" = 0.5
  # "fail" = 0.0
)

assessment_table
```

## Assessment function

```{r}
assessment <- function(predictions, data, assessment_table) {

  # Compares observation against prediction...
  # usually: eqr <- prediction / data$response
  
  eqr <- 1 - predictions / data$response
  
  # Final EQR cut! ------------------------------------------------------------
  class <- cut(eqr,
             breaks = c(1, assessment_table$value),
             labels = assessment_table$asesssment)
  return(class)
}
assessments <- assessment(predictions, data, assessment_table)
assessments
```

## Aggregation function

```{r}
aggrgation <- function(assessment) {

  # Aggregates assessments across waterbody or some other level...
  # e.g. aggregate <- assesment %>% group_by(waterbody) %>% summarise(min_assessment = min(assessment))
  aggregate <- NA
  return(aggregate)
}
aggrgation(assessment)

```

## Standard checklist

```{r}
check_list <- hera:::hera_test(standard = standard)
knitr::kable(check_list$standard_check)
```

## Update hera

```{r}

model_dataframe <- hera::model_dataframe
model <- tibble(
  analysis_name = standard$parameter,
  validation_function = NA,
  indices_function = NA,
  prediction_function = list(prediction),
  classification_function = list(assessment)
)

new_model_dataframe <- bind_rows(model_dataframe, model)
new_model_dataframe
usethis::use_data("model_dataframe" = new_model_dataframe, overwrite = TRUE)
```

## Launch app

```{r, echo=FALSE, eval=FALSE}
# shiny::shinyAppDir(
#   system.file("shiny_apps/heraapp", package="hera"),
#   options = list(width = "100%", height = 700)
# )

launch_app <- function(new_model_dataframe=NULL){
  new_model_dataframe <<- new_model_dataframe
  shiny::shinyAppDir(appDir = system.file("shiny_apps/heraapp", package="hera"))
}

launch_app(new_model_dataframe = new_model_dataframe)

```

<!-- Optional setting below!!! -->

TODO

## Diagnose

```{r}
diagnose <- function(assessment) {

  # Aggregates assessments across waterbody or some other level...
  # e.g. aggregate <- assesment %>% group_by(waterbody) %>% summarise(min_assessment = min(assessment))
  diagnosis <- tibble(
    diagnosis = "Mine water impact",
    measure = "Mine water treatment"
  )
  return(diagnosis)
}
diagnose <- diagnose(assessment)
diagnose
```

## Action

```{r}
action <- function(diagnose, data, assessment) {

  # Aggregates assessments across waterbody or some other level...
  # e.g. aggregate <- assesment %>% group_by(waterbody) %>% summarise(min_assessment = min(assessment))
  action <- tibble(
    measure = diagnose$measure,
    value = data$response - 11,
    assessment = assessment + 0.5)
  return(action)
}
action <- action(diagnose, data, assessments)
action
```

## Monitoring locations

```{r}
locations <- tibble(
  
    location_id = NA
  
)
```

## Monitoring strategy

```{r}

monitor <- function(locations) {

  # Aggregates assessments across waterbody or some other level...
  # e.g. aggregate <- assesment %>% group_by(waterbody) %>% summarise(min_assessment = min(assessment))
  monitor <- locations$location_id
  return(monitor)
}
monitor(locations)

```
